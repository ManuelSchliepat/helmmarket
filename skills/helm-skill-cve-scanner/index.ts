export async function searchByCve(cveId: string) {
  const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${encodeURIComponent(cveId)}`;
  const response = await fetch(url);
  
  if (!response.ok) {
    throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  if (!data.vulnerabilities || data.vulnerabilities.length === 0) {
    return null;
  }

  const cve = data.vulnerabilities[0].cve;
  const metrics = cve.metrics?.cvssMetricV31?.[0]?.cvssData || cve.metrics?.cvssMetricV30?.[0]?.cvssData || cve.metrics?.cvssMetricV2?.[0]?.cvssData;
  
  return {
    id: cve.id,
    description: cve.descriptions.find((d: any) => d.lang === 'en')?.value || 'No description available',
    severity: metrics?.baseSeverity || 'UNKNOWN',
    cvssScore: metrics?.baseScore || null,
    publishedDate: cve.published,
    affectedProducts: cve.configurations?.flatMap((c: any) => c.nodes?.flatMap((n: any) => n.cpeMatch?.map((m: any) => m.criteria))) || [],
    referenceUrls: cve.references?.map((r: any) => r.url) || []
  };
}

export async function searchByKeyword(keyword: string, limit: number = 10) {
  const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${encodeURIComponent(keyword)}&resultsPerPage=${limit}`;
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  if (!data.vulnerabilities) return [];

  return data.vulnerabilities.map((v: any) => {
    const cve = v.cve;
    const metrics = cve.metrics?.cvssMetricV31?.[0]?.cvssData || cve.metrics?.cvssMetricV30?.[0]?.cvssData || cve.metrics?.cvssMetricV2?.[0]?.cvssData;
    
    return {
      id: cve.id,
      description: cve.descriptions.find((d: any) => d.lang === 'en')?.value || 'No description available',
      severity: metrics?.baseSeverity || 'UNKNOWN',
      cvssScore: metrics?.baseScore || null
    };
  });
}

export async function getRecentCritical(daysBack: number = 7) {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - daysBack);

  const startStr = startDate.toISOString().split('.')[0] + 'Z';
  const endStr = endDate.toISOString().split('.')[0] + 'Z';

  const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate=${startStr}&pubEndDate=${endStr}&cvssV3Severity=CRITICAL`;
  
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  if (!data.vulnerabilities) return [];

  const results = data.vulnerabilities.map((v: any) => {
    const cve = v.cve;
    const metrics = cve.metrics?.cvssMetricV31?.[0]?.cvssData || cve.metrics?.cvssMetricV30?.[0]?.cvssData || cve.metrics?.cvssMetricV2?.[0]?.cvssData;
    
    return {
      id: cve.id,
      description: cve.descriptions.find((d: any) => d.lang === 'en')?.value || 'No description available',
      severity: metrics?.baseSeverity || 'UNKNOWN',
      cvssScore: metrics?.baseScore || null,
      publishedDate: cve.published
    };
  });

  return results.sort((a: any, b: any) => (b.cvssScore || 0) - (a.cvssScore || 0));
}

// In a real Helm skill, you would use the builder pattern to expose these.
export const plugin = {
  name: 'helm-skill-cve-scanner',
  operations: {
    searchByCve: { permission: 'allow', handler: searchByCve },
    searchByKeyword: { permission: 'allow', handler: searchByKeyword },
    getRecentCritical: { permission: 'allow', handler: getRecentCritical }
  }
};
